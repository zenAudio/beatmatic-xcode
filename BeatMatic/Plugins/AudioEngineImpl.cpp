//
//  AudioEngineImpl.cpp
//  BeatMatic
//
//  Created by Martin Percossi on 09.09.12.
//
//

#include "AudioEngineImpl.h"

#include <iostream>

DrumMachineAudioSource::DrumMachineAudioSource(MidiKeyboardState& keyboardState_) : keyboardState (keyboardState_), lastNote(0) {
    synth.addVoice(new SamplerVoice);
    synth.addVoice(new SamplerVoice);
}

void DrumMachineAudioSource::setDrumSound(String soundName, File sample) {
    WavAudioFormat wavFormat;
    
    ScopedPointer<AudioFormatReader> audioReader(wavFormat.createReaderFor(new FileInputStream(sample), true));
    
    BigInteger notes;
    notes.setRange(lastNote, 1, true);
    
    synth.addSound(new SamplerSound(soundName, *audioReader, notes,
                                    lastNote,   // root midi note
                                    0.0,  // attack time
                                    0.0,  // release time
                                    10.0  // maximum sample length
                            ));
    
    soundToNote.set(soundName, lastNote++);
}

void DrumMachineAudioSource::prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate) {
    midiCollector.reset(sampleRate);
    synth.setCurrentPlaybackSampleRate (sampleRate);
}

void DrumMachineAudioSource::releaseResources() {
}

void DrumMachineAudioSource::getNextAudioBlock(const AudioSourceChannelInfo& bufferToFill) {
    // the synth always adds its output to the audio buffer, so we have to clear it
    // first..
    bufferToFill.clearActiveBufferRegion();
    
    // fill a midi buffer with incoming messages from the midi input.
    MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages(incomingMidi, bufferToFill.numSamples);
    
    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer(incomingMidi, 0, bufferToFill.numSamples, true);
    
    // and now get the synth to process the midi events and generate its output.
    synth.renderNextBlock(*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
}

void DrumMachineAudioSource::noteOn(int note, float velocity) {
    synth.noteOn(1, note, velocity);
}

void DrumMachineAudioSource::noteOff(int note, float velocity) {
    synth.noteOff(1, note, true);
}

void DrumMachineAudioSource::audition(juce::String soundName) {
    noteOn(soundToNote[soundName], 1);
}

MidiMessageCollector& DrumMachineAudioSource::getMidiCollector() {
    return midiCollector;
}

DrumMachineSequencer::DrumMachineSequencer(AudioEngineImpl& engine) : audioEngine(engine) {
    std::memset(static_cast<void *>(pattern), 0, NUM_DRUM_VOICES*MAX_DRUM_PATTERN_LENGTH*sizeof(int));
}

DrumMachineSequencer::~DrumMachineSequencer() {
    // NOP
}

void DrumMachineSequencer::audioDeviceIOCallback (const float** inputChannelData,
                            int totalNumInputChannels,
                            float** outputChannelData,
                            int totalNumOutputChannels,
                            int numSamples)
{
    if (audioEngine.playing) {
        MidiMessageCollector& msgQueue = static_cast<DrumMachineAudioSource *>(getCurrentSource())->getMidiCollector();
       
        // this is a bit of waste, but avoiding is much more painful from programming point of
        // view: we would have to subclass our own AudioSourcePlayer with sequencer features.
        // TODO: implement this.
        for (int i = 0; i < totalNumOutputChannels; i++)
            std::memset(static_cast<void *>(outputChannelData[i]), 0, numSamples*sizeof(float));
        
        audioEngine.frameStartSamples = audioEngine.frameEndSamples;
        audioEngine.frameEndSamples += numSamples;
        
        float frameStartTicks = audioEngine.samplesToTicks(audioEngine.frameStartSamples);
        float frameEndTicks = audioEngine.samplesToTicks(audioEngine.frameEndSamples);
        
        if ((int) frameStartTicks < (int) frameEndTicks) {
            int tick = (int) frameEndTicks;
            int ntick = tick % patternLength;
            
            for (int voice = 0; voice < NUM_DRUM_VOICES; voice++) {
                if (pattern[voice][ntick] > 0) {
                    // we need to queue the appropriate note in the drum machine's synth.
                    MidiMessage msg = MidiMessage::noteOn(1, voice, (float) 1);
                    int offset = audioEngine.ticksToSamples(tick) - audioEngine.frameStartSamples;
                    msg.setTimeStamp(offset);
                    msgQueue.addMessageToQueue(msg);
                }
            }
        }
    }
    
    AudioSourcePlayer::audioDeviceIOCallback(inputChannelData, totalNumInputChannels, outputChannelData, totalNumOutputChannels, numSamples);
}

void DrumMachineSequencer::audioDeviceAboutToStart(AudioIODevice* device) {
    audioEngine.sampleRate = device->getCurrentSampleRate();
    AudioSourcePlayer::audioDeviceAboutToStart(device);
}

void DrumMachineSequencer::audioDeviceStopped() {
    AudioSourcePlayer::audioDeviceStopped();
}

AudioEngineImpl::AudioEngineImpl() : drumMachine(keyboardState), drumSequencer(*this) {
}

void AudioEngineImpl::init() {
    audioMgr.initialise(1 /* mono input */, 2 /* stereo output */, nullptr, true, String::empty, nullptr);
    
    drumSequencer.setSource(&drumMachine);
    audioMgr.addAudioCallback(&drumSequencer);
    audioMgr.addMidiInputCallback(String::empty, &(drumMachine.getMidiCollector()));
}

void AudioEngineImpl::playTestTone() {
    std::cout << "MPD: CPP: AudioEngineImpl::playTestTone" << std::endl;
    audioMgr.playTestSound();
}

void AudioEngineImpl::setDrumPreset(const char * const presetFilename) {
    std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: setting drum preset to: " << presetFilename << std::endl;
    
    File presetFile(presetFilename);
    File presetDir = presetFile.getParentDirectory();
    var preset = JSON::parse(presetFile);
    
    std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: preset json: " << preset.toString() << std::endl;
    
    auto& obj = *preset.getDynamicObject();
    
    std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: preset name: " << obj.getProperty("preset").toString()
        << "; created by: " << obj.getProperty("preset").toString() << std::endl;

    var voices = obj.getProperty("voices");
    
    BigInteger allNotes;
    allNotes.setRange(0, 128, true);
    
    for (int i = 0; i < voices.size(); i++) {
        var voice = voices[i];
        auto& obj = *voice.getDynamicObject();
        String name = obj.getProperty("voice");
        std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: adding voice: " << name << std::endl;
        
        var samples = obj.getProperty("samples");
        {
            File sample = presetDir.getChildFile(samples[0].toString());
            std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: adding sample: "
                << sample.getFullPathName() << std::endl;
            
            drumMachine.setDrumSound(name, sample);
        }
        // MPD: for now we only use the first sample, but actually we want to load these so the user can
        // select different sounds for each "voice".
//        for (int j = 0; j < samples.size(); j++) {
//            File sample = presetDir.getChildFile(samples[j].toString());
//            std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: adding sample: "
//                << sample.getFullPathName() << std::endl;
//
//        }
    }
}

void AudioEngineImpl::auditionDrum(juce::String soundName) {
    std::cout << "MPD: CPP: AudioEngineImpl::auditionDrum: auditioning " << soundName << std::endl;
    drumMachine.audition(soundName);
}

void AudioEngineImpl::setDrumPattern(const char *const patternJson) {
    std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: pattern is " << patternJson << std::endl;
    var pattern = JSON::parse(patternJson);
    auto& obj = *(pattern.getDynamicObject());
    
    drumSequencer.patternLength = 0;
    
    var tracks = obj.getProperty("tracks");
    for (int i = 0; i < tracks.size(); i++) {
        auto& trackObj = *tracks[i].getDynamicObject();
        
        var score = trackObj.getProperty("score");
        std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: score " << score.toString() << std::endl;
        std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: score array " << score.getArray()->size() << std::endl;
         
        String trackName = trackObj.getProperty("name");
        int patternIx = getDrumPatternIx(trackName);
        std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: pattern ix for " << trackName << " is " << patternIx << std::endl;
        
        if (patternIx < 0)
            throw AudioEngineException("Invalid pattern name " + trackName);
        
        std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: score length for " << trackName << " is " << score.size() << std::endl;
      
        for (int tick = 0; tick < score.size(); tick++) {
            int vel = (int) score[tick];
            std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: tick " << tick << std::endl;
            std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: score tick " << vel << std::endl;
            drumSequencer.pattern[patternIx][tick] = vel;
        }
        
        if (score.size() != drumSequencer.patternLength && drumSequencer.patternLength > 0)
            throw AudioEngineException("Pattern lengths must be the same for all voices.");
    
        drumSequencer.patternLength = score.size();
    }
    
    float bpm = obj.getProperty("bpm");
    setBpm(bpm);
    std::cout << "MPD: CPP: AudioEngineImpl::setDrumPattern: set bpm to " << bpm << std::endl;
}

void AudioEngineImpl::play() {
    std::cout << "MPD: CPP: AudioEngineImpl::play" << std::endl;
    if (!playing) {
        frameStartSamples = 0;
        frameEndSamples = 0;
        playing = true;
    }
}

void AudioEngineImpl::stop() {
    std::cout << "MPD: CPP: AudioEngineImpl::stop" << std::endl;
    if (playing) {
        playing = false;
    }
}

float AudioEngineImpl::getBpm() const {
    std::cout << "MPD: CPP: AudioEngineImpl::getBpm" << std::endl;
    return bpm;
}

void AudioEngineImpl::setBpm(float bpm) {
    std::cout << "MPD: CPP: AudioEngineImpl::setBpm:" << bpm << std::endl;
    this->bpm = bpm;
}

float AudioEngineImpl::samplesToTicks(float t_samples) {
    float t_ticks = 4.f/60.f*bpm/sampleRate*t_samples;
    return t_ticks;
}

float AudioEngineImpl::ticksToSamples(float t_ticks) {
    float t_samples = 60.f/4.0/bpm*sampleRate*t_ticks;
    return t_samples;
}

int AudioEngineImpl::getDrumPatternIx(String drumSound) {
    if (drumSound.contains("kick"))
        return 0;
    else if (drumSound.contains("snare") || drumSound.contains("clap"))
        return 1;
    else if (drumSound.contains("hat"))
        return 2;
    else
        return -1;
}

