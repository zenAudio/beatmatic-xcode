//
//  drummachine.cpp
//  BeatMatic
//
//  Created by Martin Percossi on 10.09.12.
//
//

#include "drummachine.h"
#include "AudioEngineImpl.h"

DrumMachine::DrumMachine(AudioEngineImpl& engine) : audioEngine(engine), lastNote(0) {
    std::memset(static_cast<void *>(pattern), 0, NUM_DRUM_HIT_TYPES*MAX_DRUM_PATTERN_LENGTH*sizeof(int));
    
    for (int i = 0; i < NUM_DRUM_VOICES; i++) {
        synth.addVoice(new SamplerVoice);
		mute[i] = false;
	}
}

void DrumMachine::init() {
    // we want to get notified of midi events!
    audioEngine.getAudioMgr().addMidiInputCallback(String::empty, &midiCollector);
}

void DrumMachine::setDrumSound(String soundName, File sample) {
    WavAudioFormat wavFormat;
    
    ScopedPointer<AudioFormatReader> audioReader(wavFormat.createReaderFor(new FileInputStream(sample), true));
    
    BigInteger notes;
    notes.setRange(lastNote, 1, true);
    
    synth.addSound(new SamplerSound(soundName, *audioReader, notes,
                                    lastNote,   // root midi note
                                    0.0,  // attack time
                                    0.0,  // release time
                                    10.0  // maximum sample length
                                    ));
    
    soundToNote.set(soundName, lastNote++);
}

void DrumMachine::prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate) {
    midiCollector.reset(sampleRate);
    synth.setCurrentPlaybackSampleRate (sampleRate);
}

void DrumMachine::releaseResources() {
}

void DrumMachine::getNextAudioBlock(const AudioSourceChannelInfo& bufferToFill) {
//    std::cout << "drum machine!!" << std::endl;
    auto& transport = audioEngine.getTransport();
    if (transport.isPlaying()) {
        int frameStartSamples = transport.getFrameStartSamples();
        
        float frameStartTicks = transport.getFrameStartTicks();
        float frameEndTicks = transport.getFrameEndTicks();
        
        if ((int) frameStartTicks < (int) frameEndTicks) {
            int tick = (int) frameEndTicks;
            
            if (patternLength != 0) {
                int ntick = tick % patternLength;
                
                for (int voice = 0; voice < NUM_DRUM_VOICES; voice++) {
					if (mute[voice])
						continue;
                    if (pattern[voice][ntick] > 0) {
                        // we need to queue the appropriate note in the drum machine's synth.
                        int offset = transport.ticksToSamples(tick) - frameStartSamples;
                        if (offset > 0) {
							MidiMessage msg = MidiMessage::noteOn(1, voice, (float) 1.0);
                            msg.setTimeStamp(offset);
                            midiCollector.addMessageToQueue(msg);
                        }
                    }
                }
            }
        }
    }
    
    // the synth always adds its output to the audio buffer, so we have to clear it
    // first..
    bufferToFill.clearActiveBufferRegion();
    
    // fill a midi buffer with incoming messages from the midi input.
    MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages(incomingMidi, bufferToFill.numSamples);
    
    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer(incomingMidi, 0, bufferToFill.numSamples, true);
    
    // and now get the synth to process the midi events and generate its output.
    synth.renderNextBlock(*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
    bufferToFill.buffer->applyGain(0, 0, bufferToFill.numSamples, 0.2);
    bufferToFill.buffer->applyGain(1, 0, bufferToFill.numSamples, 0.2);
}

void DrumMachine::setDrumPattern(const char *const patternJson) {
//    std::cout << "MPD: CPP: DrumMachine::setDrumPattern: pattern is " << patternJson << std::endl;
    var pattern = JSON::parse(patternJson);
    auto& obj = *(pattern.getDynamicObject());
    
    patternLength = 0;
    
    var tracks = obj.getProperty("tracks");
    for (int i = 0; i < tracks.size(); i++) {
        auto& trackObj = *tracks[i].getDynamicObject();
        
        var score = trackObj.getProperty("score");
//        std::cout << "MPD: CPP: DrumMachine::setDrumPattern: score " << score.toString() << std::endl;
//        std::cout << "MPD: CPP: DrumMachine::setDrumPattern: score array " << score.getArray()->size() << std::endl;
        
        String trackName = trackObj.getProperty("name");
        int patternIx = getDrumPatternIx(trackName);
//        std::cout << "MPD: CPP: DrumMachine::setDrumPattern: pattern ix for " << trackName << " is " << patternIx << std::endl;
        
        if (patternIx < 0)
            throw AudioEngineException("Invalid pattern name " + trackName);
        
//        std::cout << "MPD: CPP: DrumMachine::setDrumPattern: score length for " << trackName << " is " << score.size() << std::endl;
        
        for (int tick = 0; tick < score.size(); tick++) {
            int vel = (int) score[tick];
//            std::cout << "MPD: CPP: DrumMachine::setDrumPattern: tick " << tick << std::endl;
//            std::cout << "MPD: CPP: DrumMachine::setDrumPattern: score tick " << vel << std::endl;
            this->pattern[patternIx][tick] = vel;
        }
        
        if (score.size() != patternLength && patternLength > 0)
            throw AudioEngineException("Pattern lengths must be the same for all voices.");
        
        patternLength = score.size();
    }
    
	// FIXME: remove following two lines of code once we have DIRAC WORKING.k
//    float bpm = obj.getProperty("bpm");
//    audioEngine.getTransport().setBpm(bpm);
	
//    std::cout << "MPD: CPP: DrumMachine::setDrumPattern: set bpm to " << bpm << std::endl;
}

void DrumMachine::setDrumPreset(const char * const presetFilename) {
//    std::cout << "MPD: CPP: DrumMachine::setDrumPreset: setting drum preset to: " << presetFilename << std::endl;
    
    File presetFile(presetFilename);
    File presetDir = presetFile.getParentDirectory();
    var preset = JSON::parse(presetFile);
    
//    std::cout << "MPD: CPP: DrumMachine::setDrumPreset: preset json: " << preset.toString() << std::endl;
    
    auto& obj = *preset.getDynamicObject();
    
//    std::cout << "MPD: CPP: DrumMachine::setDrumPreset: preset name: " << obj.getProperty("preset").toString()
//              << "; created by: " << obj.getProperty("preset").toString() << std::endl;
    
    var voices = obj.getProperty("voices");
    
    BigInteger allNotes;
    allNotes.setRange(0, 128, true);
    
    for (int i = 0; i < voices.size(); i++) {
        var voice = voices[i];
        auto& obj = *voice.getDynamicObject();
        String name = obj.getProperty("voice");
//        std::cout << "MPD: CPP: DrumMachine::setDrumPreset: adding voice: " << name << std::endl;
        
        var samples = obj.getProperty("samples");
        {
            File sample = presetDir.getChildFile(samples[0].toString());
//            std::cout << "MPD: CPP: DrumMachine::setDrumPreset: adding sample: "
//                      << sample.getFullPathName() << std::endl;
            
            setDrumSound(name, sample);
        }
        // MPD: for now we only use the first sample, but actually we want to load these so the user can
        // select different sounds for each "voice".
        //        for (int j = 0; j < samples.size(); j++) {
        //            File sample = presetDir.getChildFile(samples[j].toString());
        //            std::cout << "MPD: CPP: AudioEngineImpl::setDrumPreset: adding sample: "
        //                << sample.getFullPathName() << std::endl;
        //
        //        }
    }
}

int DrumMachine::getDrumPatternIx(String drumSound) {
    auto sound = drumSound.toLowerCase();
    if (sound.contains("kick"))
        return 0;
    else if (sound.contains("snare") || sound.contains("clap"))
        return 1;
    else if (sound.contains("hat"))
        return 2;
    else
        return -1;
}

void DrumMachine::noteOn(int note, float velocity) {
    synth.noteOn(1, note, velocity);
}

void DrumMachine::noteOff(int note, float velocity) {
    synth.noteOff(1, note, true);
}

void DrumMachine::audition(juce::String soundName) {
    noteOn(soundToNote[soundName], 1);
}

void DrumMachine::muteVoice(String voice, bool onOff) {
	mute[soundToNote[voice]] = onOff;
}
